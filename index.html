<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Sky Battle - Multiplayer Airplane Combat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0a1a;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }
        
        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a1a 100%);
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(10, 10, 26, 0.95);
            pointer-events: auto;
            transition: opacity 0.3s ease;
        }
        
        .screen.hidden {
            display: none;
        }
        
        h1 {
            font-size: 4rem;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            margin-bottom: 1rem;
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.8)); }
            to { filter: drop-shadow(0 0 40px rgba(255, 0, 255, 0.8)); }
        }
        
        .btn {
            padding: 15px 40px;
            margin: 10px;
            font-size: 1.2rem;
            border: 2px solid #00ffff;
            background: transparent;
            color: #00ffff;
            cursor: pointer;
            border-radius: 30px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .btn:hover {
            background: #00ffff;
            color: #0a0a1a;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
        }
        
        .btn.secondary {
            border-color: #ff00ff;
            color: #ff00ff;
        }
        
        .btn.secondary:hover {
            background: #ff00ff;
            color: #0a0a1a;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.6);
        }
        
        input {
            padding: 15px 20px;
            font-size: 1.5rem;
            border: 2px solid #00ffff;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            border-radius: 10px;
            text-align: center;
            width: 200px;
            margin: 10px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }
        
        input:focus {
            outline: none;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .room-code {
            font-size: 3rem;
            color: #ffff00;
            text-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
            letter-spacing: 10px;
            margin: 20px 0;
        }
        
        .hud {
            position: absolute;
            pointer-events: none;
        }
        
        .health-bar {
            top: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #00ffff;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            transition: width 0.3s ease;
        }
        
        .score {
            top: 20px;
            right: 20px;
            font-size: 1.5rem;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .minimap {
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 10px;
        }
        
        .leaderboard {
            top: 60px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff00ff;
            border-radius: 10px;
            padding: 15px;
            min-width: 150px;
        }
        
        .leaderboard h3 {
            color: #ff00ff;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .leaderboard-item {
            color: #fff;
            padding: 5px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .touch-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: none;
        }
        
        .touch-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 2px solid #00ffff;
            position: absolute;
            pointer-events: auto;
        }
        
        .touch-btn:active {
            background: rgba(0, 255, 255, 0.6);
        }
        
        .touch-up { bottom: 80px; left: 70px; }
        .touch-down { bottom: 0; left: 70px; }
        .touch-left { bottom: 40px; left: 0; }
        .touch-right { bottom: 40px; left: 140px; }
        .touch-fire { 
            bottom: 40px; 
            right: 20px; 
            left: auto;
            background: rgba(255, 0, 0, 0.3);
            border-color: #ff0000;
            width: 90px;
            height: 90px;
        }
        
        @media (max-width: 768px) {
            h1 { font-size: 2.5rem; }
            .touch-controls { display: block; }
            .btn { padding: 12px 30px; font-size: 1rem; }
        }
        
        .plane-select {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .plane-option {
            padding: 20px;
            border: 2px solid #444;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            color: #fff;
        }
        
        .plane-option:hover, .plane-option.selected {
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .plane-option h4 {
            color: #00ffff;
            margin-bottom: 10px;
        }
        
        .plane-stats {
            font-size: 0.8rem;
            color: #aaa;
        }
        
        .waiting-text {
            color: #ffff00;
            font-size: 1.2rem;
            margin-top: 20px;
            animation: pulse 1s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <!-- Main Menu -->
        <div id="mainMenu" class="screen">
            <h1>NEON SKY BATTLE</h1>
            <button class="btn" onclick="showScreen('createRoom')">Create Room</button>
            <button class="btn secondary" onclick="showScreen('joinRoom')">Join Room</button>
            <button class="btn" onclick="showScreen('planeSelect')">Select Plane</button>
        </div>
        
        <!-- Create Room -->
        <div id="createRoom" class="screen hidden">
            <h1>CREATE ROOM</h1>
            <p style="color: #fff; margin-bottom: 20px;">Your Room Code:</p>
            <div class="room-code" id="roomCodeDisplay">----</div>
            <p class="waiting-text">Waiting for players...</p>
            <p style="color: #888; margin-top: 20px;">Share this code with friends!</p>
            <button class="btn" onclick="startGame()">Start Game</button>
            <button class="btn secondary" onclick="showScreen('mainMenu')">Back</button>
        </div>
        
        <!-- Join Room -->
        <div id="joinRoom" class="screen hidden">
            <h1>JOIN ROOM</h1>
            <p style="color: #fff; margin-bottom: 20px;">Enter 4-digit Room Code:</p>
            <input type="text" id="roomCodeInput" maxlength="4" placeholder="0000">
            <div>
                <button class="btn" onclick="joinRoom()">Join</button>
                <button class="btn secondary" onclick="showScreen('mainMenu')">Back</button>
            </div>
        </div>
        
        <!-- Plane Select -->
        <div id="planeSelect" class="screen hidden">
            <h1>SELECT YOUR PLANE</h1>
            <div class="plane-select">
                <div class="plane-option selected" data-plane="fighter" onclick="selectPlane('fighter')">
                    <h4>üöÄ Fighter</h4>
                    <div class="plane-stats">
                        Speed: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ<br>
                        Health: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ<br>
                        Fire Rate: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ
                    </div>
                </div>
                <div class="plane-option" data-plane="tank" onclick="selectPlane('tank')">
                    <h4>üõ°Ô∏è Tank</h4>
                    <div class="plane-stats">
                        Speed: ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ<br>
                        Health: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ<br>
                        Fire Rate: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ
                    </div>
                </div>
                <div class="plane-option" data-plane="speedster" onclick="selectPlane('speedster')">
                    <h4>‚ö° Speedster</h4>
                    <div class="plane-stats">
                        Speed: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ<br>
                        Health: ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ<br>
                        Fire Rate: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ
                    </div>
                </div>
                <div class="plane-option" data-plane="bomber" onclick="selectPlane('bomber')">
                    <h4>üí£ Bomber</h4>
                    <div class="plane-stats">
                        Speed: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ<br>
                        Health: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ<br>
                        Fire Rate: ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ
                    </div>
                </div>
            </div>
            <button class="btn" onclick="showScreen('mainMenu')">Done</button>
        </div>
        
        <!-- Game Over -->
        <div id="gameOver" class="screen hidden">
            <h1>GAME OVER</h1>
            <p style="color: #fff; font-size: 1.5rem; margin: 20px 0;">
                Final Score: <span id="finalScore" style="color: #ffff00;">0</span>
            </p>
            <p style="color: #fff; font-size: 1.2rem; margin-bottom: 20px;">
                Rank: <span id="finalRank" style="color: #00ffff;">1st</span>
            </p>
            <button class="btn" onclick="restartGame()">Play Again</button>
            <button class="btn secondary" onclick="showScreen('mainMenu')">Main Menu</button>
        </div>
        
        <!-- HUD -->
        <div id="hud" class="hud hidden">
            <div class="health-bar">
                <div class="health-fill" id="healthFill" style="width: 100%;"></div>
            </div>
            <div class="score">Score: <span id="scoreDisplay">0</span></div>
            <div class="leaderboard">
                <h3>LEADERBOARD</h3>
                <div id="leaderboardList"></div>
            </div>
            <canvas class="minimap" id="minimap" width="150" height="150"></canvas>
        </div>
        
        <!-- Touch Controls -->
        <div class="touch-controls" id="touchControls">
            <div class="touch-btn touch-up" data-key="ArrowUp"></div>
            <div class="touch-btn touch-down" data-key="ArrowDown"></div>
            <div class="touch-btn touch-left" data-key="ArrowLeft"></div>
            <div class="touch-btn touch-right" data-key="ArrowRight"></div>
            <div class="touch-btn touch-fire" data-key=" "></div>
        </div>
    </div>

    <script>
        // Game Constants
        const CANVAS_WIDTH = window.innerWidth;
        const CANVAS_HEIGHT = window.innerHeight;
        const WORLD_WIDTH = 3000;
        const WORLD_HEIGHT = 3000;
        
        // Plane Types
        const PLANE_TYPES = {
            fighter: { speed: 6, health: 100, fireRate: 200, bulletSpeed: 12, color: '#00ffff' },
            tank: { speed: 3, health: 200, fireRate: 300, bulletSpeed: 8, color: '#ff6600' },
            speedster: { speed: 9, health: 60, fireRate: 150, bulletSpeed: 15, color: '#ff00ff' },
            bomber: { speed: 4, health: 150, fireRate: 400, bulletSpeed: 6, color: '#ffff00' }
        };
        
        // Power-up Types
        const POWERUPS = {
            speed: { color: '#00ff00', duration: 5000, icon: '‚ö°' },
            shield: { color: '#0088ff', duration: 8000, icon: 'üõ°Ô∏è' },
            rapid: { color: '#ff00ff', duration: 6000, icon: 'üî•' },
            bomb: { color: '#ff0000', duration: 0, icon: 'üí£' }
        };
        
        // Game State
        let canvas, ctx, minimapCtx;
        let gameLoop;
        let lastTime = 0;
        let screenShake = 0;
        
        let player = null;
        let players = new Map();
        let bullets = [];
        let particles = [];
        let powerups = [];
        let clouds = [];
        let stars = [];
        
        let keys = {};
        let mouse = { x: 0, y: 0 };
        let camera = { x: 0, y: 0 };
        
        let roomCode = '';
        let selectedPlaneType = 'fighter';
        let gameActive = false;
        let playerId = Math.random().toString(36).substr(2, 9);
        
        // Simulated multiplayer (polling-based)
        let lastSyncTime = 0;
        const SYNC_INTERVAL = 50; // 20 updates per second
        
        // Initialize
        window.onload = function() {
            canvas = document.getElementById('gameCanvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx = canvas.getContext('2d');
            
            const minimap = document.getElementById('minimap');
            minimapCtx = minimap.getContext('2d');
            
            initBackground();
            setupEventListeners();
            
            // Start background animation
            requestAnimationFrame(renderBackground);
        };
        
        function initBackground() {
            // Create stars
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    size: Math.random() * 2 + 0.5,
                    brightness: Math.random()
                });
            }
            
            // Create clouds
            for (let i = 0; i < 30; i++) {
                clouds.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    size: Math.random() * 100 + 50,
                    speed: Math.random() * 0.5 + 0.2
                });
            }
        }
        
        function setupEventListeners() {
            // Keyboard
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                if (e.key === ' ' && gameActive) {
                    e.preventDefault();
                }
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            // Mouse
            canvas.addEventListener('mousemove', (e) => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            });
            
            // Touch controls
            const touchBtns = document.querySelectorAll('.touch-btn');
            touchBtns.forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys[btn.dataset.key] = true;
                });
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys[btn.dataset.key] = false;
                });
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
            
            // Room code input
            const roomInput = document.getElementById('roomCodeInput');
            roomInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 4);
            });
        }
        
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(screenId).classList.remove('hidden');
            
            if (screenId === 'createRoom') {
                generateRoomCode();
            }
        }
        
        function generateRoomCode() {
            roomCode = Math.random().toString(36).substr(2, 4).toUpperCase();
            document.getElementById('roomCodeDisplay').textContent = roomCode;
        }
        
        function selectPlane(type) {
            selectedPlaneType = type;
            document.querySelectorAll('.plane-option').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelector(`[data-plane="${type}"]`).classList.add('selected');
        }
        
        function joinRoom() {
            const code = document.getElementById('roomCodeInput').value.toUpperCase();
            if (code.length === 4) {
                roomCode = code;
                startGame();
            } else {
                alert('Please enter a valid 4-digit room code');
            }
        }
        
        function startGame() {
            showScreen('hud');
            document.getElementById('touchControls').style.display = 'flex';
            
            // Create player
            const planeStats = PLANE_TYPES[selectedPlaneType];
            player = {
                id: playerId,
                x: Math.random() * WORLD_WIDTH,
                y: Math.random() * WORLD_HEIGHT,
                angle: 0,
                vx: 0,
                vy: 0,
                health: planeStats.health,
                maxHealth: planeStats.health,
                score: 0,
                planeType: selectedPlaneType,
                lastShot: 0,
                powerups: {},
                trail: []
            };
            
            players.set(playerId, player);
            
            // Add some AI bots for single-player testing
            for (let i = 0; i < 3; i++) {
                const botId = 'bot_' + i;
                const botTypes = Object.keys(PLANE_TYPES);
                const botType = botTypes[Math.floor(Math.random() * botTypes.length)];
                const botStats = PLANE_TYPES[botType];
                
                players.set(botId, {
                    id: botId,
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    angle: Math.random() * Math.PI * 2,
                    vx: 0,
                    vy: 0,
                    health: botStats.health,
                    maxHealth: botStats.health,
                    score: 0,
                    planeType: botType,
                    lastShot: 0,
                    powerups: {},
                    trail: [],
                    isBot: true,
                    targetAngle: Math.random() * Math.PI * 2
                });
            }
            
            // Spawn initial powerups
            for (let i = 0; i < 10; i++) {
                spawnPowerup();
            }
            
            gameActive = true;
            lastTime = performance.now();
            gameLoop = requestAnimationFrame(gameUpdate);
        }
        
        function spawnPowerup() {
            const types = Object.keys(POWERUPS);
            const type = types[Math.floor(Math.random() * types.length)];
            powerups.push({
                x: Math.random() * WORLD_WIDTH,
                y: Math.random() * WORLD_HEIGHT,
                type: type,
                size: 25,
                pulse: 0
            });
        }
        
        function gameUpdate(currentTime) {
            if (!gameActive) return;
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            updatePlayer(deltaTime);
            updateBots(deltaTime);
            updateBullets(deltaTime);
            updateParticles(deltaTime);
            updatePowerups(deltaTime);
            updateBackground(deltaTime);
            
            checkCollisions();
            updateCamera();
            
            // Sync with "server" (simulated)
            if (currentTime - lastSyncTime > SYNC_INTERVAL) {
                syncGameState();
                lastSyncTime = currentTime;
            }
            
            // Update HUD
            updateHUD();
            
            // Render
            render();
            
            gameLoop = requestAnimationFrame(gameUpdate);
        }
        
        function updatePlayer(deltaTime) {
            if (!player) return;
            
            const stats = PLANE_TYPES[player.planeType];
            let speed = stats.speed;
            let fireRate = stats.fireRate;
            
            // Apply powerups
            if (player.powerups.speed && Date.now() < player.powerups.speed) {
                speed *= 1.5;
            }
            if (player.powerups.rapid && Date.now() < player.powerups.rapid) {
                fireRate *= 0.5;
            }
            
            // Movement
            let ax = 0, ay = 0;
            
            if (keys['ArrowUp'] || keys['w'] || keys['W']) ay = -1;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) ay = 1;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) ax = -1;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) ax = 1;
            
            // Normalize diagonal movement
            if (ax !== 0 && ay !== 0) {
                ax *= 0.707;
                ay *= 0.707;
            }
            
            player.vx += ax * 0.5;
            player.vy += ay * 0.5;
            
            // Friction
            player.vx *= 0.95;
            player.vy *= 0.95;
            
            // Limit speed
            const velocity = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            if (velocity > speed) {
                player.vx = (player.vx / velocity) * speed;
                player.vy = (player.vy / velocity) * speed;
            }
            
            // Update position
            player.x += player.vx;
            player.y += player.vy;
            
            // World bounds
            player.x = Math.max(30, Math.min(WORLD_WIDTH - 30, player.x));
            player.y = Math.max(30, Math.min(WORLD_HEIGHT - 30, player.y));
            
            // Calculate angle based on velocity
            if (velocity > 0.1) {
                player.angle = Math.atan2(player.vy, player.vx);
            }
            
            // Trail
            if (velocity > 1) {
                player.trail.push({ x: player.x, y: player.y, life: 1 });
            }
            
            // Update trail
            player.trail = player.trail.filter(t => {
                t.life -= 0.05;
                return t.life > 0;
            });
            
            // Shooting
            if ((keys[' '] || keys['Enter'] || keys['z'] || keys['Z']) && Date.now() - player.lastShot > fireRate) {
                shootBullet(player);
                player.lastShot = Date.now();
            }
        }
        
        function updateBots(deltaTime) {
            players.forEach((p, id) => {
                if (!p.isBot || p.health <= 0) return;
                
                const stats = PLANE_TYPES[p.planeType];
                
                // Simple AI: move randomly, occasionally change direction
                if (Math.random() < 0.02) {
                    p.targetAngle = Math.random() * Math.PI * 2;
                }
                
                // Smoothly turn towards target angle
                let angleDiff = p.targetAngle - p.angle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                p.angle += angleDiff * 0.05;
                
                // Move forward
                p.vx = Math.cos(p.angle) * stats.speed * 0.5;
                p.vy = Math.sin(p.angle) * stats.speed * 0.5;
                
                p.x += p.vx;
                p.y += p.vy;
                
                // Bounce off walls
                if (p.x < 30 || p.x > WORLD_WIDTH - 30) {
                    p.targetAngle = Math.PI - p.angle;
                    p.x = Math.max(30, Math.min(WORLD_WIDTH - 30, p.x));
                }
                if (p.y < 30 || p.y > WORLD_HEIGHT - 30) {
                    p.targetAngle = -p.angle;
                    p.y = Math.max(30, Math.min(WORLD_HEIGHT - 30, p.y));
                }
                
                // Trail
                p.trail.push({ x: p.x, y: p.y, life: 1 });
                p.trail = p.trail.filter(t => {
                    t.life -= 0.05;
                    return t.life > 0;
                });
                
                // Random shooting
                if (Math.random() < 0.02 && Date.now() - p.lastShot > stats.fireRate) {
                    shootBullet(p);
                    p.lastShot = Date.now();
                }
            });
        }
        
        function shootBullet(shooter) {
            const stats = PLANE_TYPES[shooter.planeType];
            const spread = shooter.powerups.rapid && Date.now() < shooter.powerups.rapid ? 0.2 : 0;
            
            bullets.push({
                x: shooter.x + Math.cos(shooter.angle) * 30,
                y: shooter.y + Math.sin(shooter.angle) * 30,
                vx: Math.cos(shooter.angle + (Math.random() - 0.5) * spread) * stats.bulletSpeed,
                vy: Math.sin(shooter.angle + (Math.random() - 0.5) * spread) * stats.bulletSpeed,
                owner: shooter.id,
                color: stats.color,
                life: 100
            });
            
            // Play shoot sound (simulated with visual feedback)
            createMuzzleFlash(shooter);
        }
        
        function createMuzzleFlash(shooter) {
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: shooter.x + Math.cos(shooter.angle) * 30,
                    y: shooter.y + Math.sin(shooter.angle) * 30,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    life: 0.5,
                    color: '#ffff00',
                    size: Math.random() * 5 + 2
                });
            }
        }
        
        function updateBullets(deltaTime) {
            bullets = bullets.filter(b => {
                b.x += b.vx;
                b.y += b.vy;
                b.life--;
                
                // Remove if out of bounds or expired
                return b.life > 0 && 
                       b.x > 0 && b.x < WORLD_WIDTH && 
                       b.y > 0 && b.y < WORLD_HEIGHT;
            });
        }
        
        function updateParticles(deltaTime) {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                p.vx *= 0.98;
                p.vy *= 0.98;
                return p.life > 0;
            });
        }
        
        function updatePowerups(deltaTime) {
            powerups.forEach(p => {
                p.pulse += 0.1;
            });
            
            // Spawn new powerups occasionally
            if (Math.random() < 0.001 && powerups.length < 20) {
                spawnPowerup();
            }
        }
        
        function updateBackground(deltaTime) {
            clouds.forEach(c => {
                c.x += c.speed;
                if (c.x > WORLD_WIDTH + c.size) {
                    c.x = -c.size;
                }
            });
        }
        
        function checkCollisions() {
            // Bullet-Player collisions
            bullets.forEach((b, bi) => {
                players.forEach((p, pid) => {
                    if (p.health <= 0 || b.owner === pid) return;
                    
                    const dx = b.x - p.x;
                    const dy = b.y - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 25) {
                        // Hit!
                        const damage = 10;
                        const hasShield = p.powerups.shield && Date.now() < p.powerups.shield;
                        
                        if (!hasShield) {
                            p.health -= damage;
                            
                            // Screen shake for player
                            if (pid === playerId) {
                                screenShake = 10;
                            }
                            
                            // Create explosion
                            createExplosion(p.x, p.y, b.color);
                            
                            // Award score to shooter
                            const shooter = players.get(b.owner);
                            if (shooter) {
                                shooter.score += 10;
                            }
                            
                            // Check for kill
                            if (p.health <= 0) {
                                createBigExplosion(p.x, p.y);
                                if (shooter) {
                                    shooter.score += 100;
                                }
                                
                                // Respawn
                                setTimeout(() => {
                                    p.health = p.maxHealth;
                                    p.x = Math.random() * WORLD_WIDTH;
                                    p.y = Math.random() * WORLD_HEIGHT;
                                    p.vx = 0;
                                    p.vy = 0;
                                }, 2000);
                            }
                        } else {
                            // Shield hit effect
                            createSparkles(p.x, p.y, '#0088ff');
                        }
                        
                        // Remove bullet
                        b.life = 0;
                    }
                });
            });
            
            // Player-Powerup collisions
            if (player && player.health > 0) {
                powerups = powerups.filter(p => {
                    const dx = p.x - player.x;
                    const dy = p.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 30) {
                        // Collect powerup
                        applyPowerup(player, p.type);
                        createSparkles(p.x, p.y, POWERUPS[p.type].color);
                        return false;
                    }
                    return true;
                });
            }
        }
        
        function applyPowerup(p, type) {
            const powerup = POWERUPS[type];
            
            if (type === 'bomb') {
                // Bomb destroys nearby enemies
                players.forEach((other, id) => {
                    if (id !== p.id && other.health > 0) {
                        const dx = other.x - p.x;
                        const dy = other.y - p.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 300) {
                            other.health -= 50;
                            createExplosion(other.x, other.y, '#ff0000');
                            if (other.health <= 0) {
                                createBigExplosion(other.x, other.y);
                                p.score += 100;
                            }
                        }
                    }
                });
                createBigExplosion(p.x, p.y);
            } else {
                p.powerups[type] = Date.now() + powerup.duration;
            }
        }
        
        function createExplosion(x, y, color) {
            for (let i = 0; i < 15; i++) {
                const angle = (Math.PI * 2 / 15) * i;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * (Math.random() * 5 + 2),
                    vy: Math.sin(angle) * (Math.random() * 5 + 2),
                    life: 1,
                    color: color,
                    size: Math.random() * 8 + 4
                });
            }
        }
        
        function createBigExplosion(x, y) {
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 8 + 3;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.5,
                    color: ['#ff0000', '#ff6600', '#ffff00', '#ffffff'][Math.floor(Math.random() * 4)],
                    size: Math.random() * 12 + 6
                });
            }
        }
        
        function createSparkles(x, y, color) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 0.8,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }
        
        function updateCamera() {
            if (!player) return;
            
            // Smooth camera follow
            const targetX = player.x - canvas.width / 2;
            const targetY = player.y - canvas.height / 2;
            
            camera.x += (targetX - camera.x) * 0.1;
            camera.y += (targetY - camera.y) * 0.1;
            
            // Clamp camera to world bounds
            camera.x = Math.max(0, Math.min(WORLD_WIDTH - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(WORLD_HEIGHT - canvas.height, camera.y));
            
            // Decay screen shake
            if (screenShake > 0) {
                screenShake *= 0.9;
                if (screenShake < 0.5) screenShake = 0;
            }
        }
        
        function syncGameState() {
            // In a real implementation, this would send data to a server
            // For now, we just simulate the game state
        }
        
        function updateHUD() {
            if (!player) return;
            
            // Health bar
            const healthPercent = (player.health / player.maxHealth) * 100;
            document.getElementById('healthFill').style.width = healthPercent + '%';
            
            // Score
            document.getElementById('scoreDisplay').textContent = player.score;
            
            // Leaderboard
            const sortedPlayers = Array.from(players.values())
                .sort((a, b) => b.score - a.score)
                .slice(0, 5);
            
            let leaderboardHTML = '';
            sortedPlayers.forEach((p, i) => {
                const isPlayer = p.id === playerId;
                const color = isPlayer ? '#00ffff' : '#fff';
                leaderboardHTML += `
                    <div class="leaderboard-item" style="color: ${color}">
                        <span>${i + 1}. ${isPlayer ? 'You' : (p.isBot ? 'Bot' : 'Player')}</span>
                        <span>${p.score}</span>
                    </div>
                `;
            });
            document.getElementById('leaderboardList').innerHTML = leaderboardHTML;
        }
        
        function render() {
            // Clear canvas
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply screen shake
            ctx.save();
            if (screenShake > 0) {
                const shakeX = (Math.random() - 0.5) * screenShake;
                const shakeY = (Math.random() - 0.5) * screenShake;
                ctx.translate(shakeX, shakeY);
            }
            
            // Draw background
            renderGameBackground();
            
            // Draw world
            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            
            // Draw powerups
            powerups.forEach(p => {
                const pulse = Math.sin(p.pulse) * 5;
                const powerupInfo = POWERUPS[p.type];
                
                // Glow
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size + pulse);
                gradient.addColorStop(0, powerupInfo.color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size + pulse + 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Icon
                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(powerupInfo.icon, p.x, p.y);
            });
            
            // Draw bullets
            bullets.forEach(b => {
                ctx.shadowBlur = 10;
                ctx.shadowColor = b.color;
                ctx.fillStyle = b.color;
                ctx.beginPath();
                ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            // Draw players
            players.forEach(p => {
                if (p.health <= 0) return;
                
                const stats = PLANE_TYPES[p.planeType];
                
                // Draw trail
                p.trail.forEach((t, i) => {
                    const alpha = t.life * 0.5;
                    ctx.fillStyle = stats.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, 3 + i * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw plane
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.angle);
                
                // Shield effect
                if (p.powerups.shield && Date.now() < p.powerups.shield) {
                    ctx.strokeStyle = '#0088ff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, 35, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.fillStyle = 'rgba(0, 136, 255, 0.2)';
                    ctx.fill();
                }
                
                // Glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = stats.color;
                
                // Plane body
                ctx.fillStyle = stats.color;
                ctx.beginPath();
                ctx.moveTo(20, 0);
                ctx.lineTo(-15, -12);
                ctx.lineTo(-10, 0);
                ctx.lineTo(-15, 12);
                ctx.closePath();
                ctx.fill();
                
                // Cockpit
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Wings
                ctx.fillStyle = stats.color;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.moveTo(5, -5);
                ctx.lineTo(-5, -20);
                ctx.lineTo(-10, -20);
                ctx.lineTo(-5, -5);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(5, 5);
                ctx.lineTo(-5, 20);
                ctx.lineTo(-10, 20);
                ctx.lineTo(-5, 5);
                ctx.closePath();
                ctx.fill();
                
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
                
                ctx.restore();
                
                // Health bar above plane
                const barWidth = 40;
                const barHeight = 4;
                const healthPercent = p.health / p.maxHealth;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(p.x - barWidth/2, p.y - 40, barWidth, barHeight);
                
                ctx.fillStyle = healthPercent > 0.5 ? '#0f0' : healthPercent > 0.25 ? '#ff0' : '#f00';
                ctx.fillRect(p.x - barWidth/2, p.y - 40, barWidth * healthPercent, barHeight);
            });
            
            // Draw particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            });
            
            // Draw world border
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 5;
            ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
            
            ctx.restore();
            ctx.restore();
            
            // Draw minimap
            renderMinimap();
        }
        
        function renderGameBackground() {
            // Draw stars
            ctx.fillStyle = '#fff';
            stars.forEach(s => {
                const x = s.x - camera.x * 0.5;
                const y = s.y - camera.y * 0.5;
                
                // Wrap around for parallax
                const wrapX = ((x % WORLD_WIDTH) + WORLD_WIDTH) % WORLD_WIDTH;
                const wrapY = ((y % WORLD_HEIGHT) + WORLD_HEIGHT) % WORLD_HEIGHT;
                
                if (wrapX > camera.x - 100 && wrapX < camera.x + canvas.width + 100 &&
                    wrapY > camera.y - 100 && wrapY < camera.y + canvas.height + 100) {
                    ctx.globalAlpha = s.brightness;
                    ctx.beginPath();
                    ctx.arc(wrapX - camera.x * 0.5, wrapY - camera.y * 0.5, s.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1;
            
            // Draw clouds
            clouds.forEach(c => {
                const x = c.x - camera.x;
                const y = c.y - camera.y;
                
                if (x > -c.size && x < canvas.width + c.size &&
                    y > -c.size && y < canvas.height + c.size) {
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, c.size);
                    gradient.addColorStop(0, 'rgba(100, 100, 150, 0.1)');
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, c.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
        
        function renderMinimap() {
            const mm = document.getElementById('minimap');
            const mmCtx = mm.getContext('2d');
            
            // Clear
            mmCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            mmCtx.fillRect(0, 0, 150, 150);
            
            // Scale
            const scaleX = 150 / WORLD_WIDTH;
            const scaleY = 150 / WORLD_HEIGHT;
            
            // Draw players
            players.forEach(p => {
                if (p.health <= 0) return;
                
                const x = p.x * scaleX;
                const y = p.y * scaleY;
                
                mmCtx.fillStyle = p.id === playerId ? '#00ffff' : '#ff00ff';
                mmCtx.beginPath();
                mmCtx.arc(x, y, p.id === playerId ? 4 : 3, 0, Math.PI * 2);
                mmCtx.fill();
            });
            
            // Draw viewport rectangle
            mmCtx.strokeStyle = '#fff';
            mmCtx.lineWidth = 1;
            mmCtx.strokeRect(
                camera.x * scaleX,
                camera.y * scaleY,
                canvas.width * scaleX,
                canvas.height * scaleY
            );
        }
        
        function renderBackground() {
            if (gameActive) return;
            
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw animated stars
            const time = Date.now() * 0.001;
            
            stars.forEach((s, i) => {
                const twinkle = Math.sin(time + i) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${s.brightness * twinkle})`;
                ctx.beginPath();
                ctx.arc(s.x % canvas.width, s.y % canvas.height, s.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            requestAnimationFrame(renderBackground);
        }
        
        function restartGame() {
            // Reset game state
            bullets = [];
            particles = [];
            powerups = [];
            players.clear();
            
            gameActive = false;
            cancelAnimationFrame(gameLoop);
            
            startGame();
        }
        
        // Prevent context menu on right click
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>
<!-- Trigger build Sat Feb 28 05:50:13 AM CST 2026 -->
